const { map, filter, takeWhile, scan, repeat } = require("rxjs/operators");

class BasicRXJS {
  function1(inputStream$) {
    return inputStream$.pipe(
      filter(s => s.length > 3),
      map(s => s.toLowerCase())
    );
  }

  function2(inputStream$) {
    return inputStream$.pipe(
      map(s => new Set(s.split("")).size)
    );
  }

  function3(inputStream$) {
    return inputStream$.pipe(
      takeWhile(s => s !== "end")
    );
  }

  function4(inputStream$) {
    return inputStream$.pipe(
      scan((acc, x) => acc + x, 0),
      repeat(2)
    );
  }
}

module.exports = { BasicRXJS };






#include <bits/stdc++.h>
using namespace std;

long long determineMaxDataFlow(vector<int> bandwidth, long long streamCount) {
    int n = (int)bandwidth.size();
    sort(bandwidth.begin(), bandwidth.end());          
    long long K = streamCount;
    long long totalPairs = 1LL * n * n;
    if (K > totalPairs) K = totalPairs;

    using Node = tuple<long long,int,int>;
    priority_queue<Node> pq;
    unordered_set<long long> seen;
    auto key = [&](int i,int j)->long long { return 1LL*i*n + j; };

    pq.push({(long long)bandwidth[n-1] + bandwidth[n-1], n-1, n-1});
    seen.insert(key(n-1,n-1));

    long long ans = 0;
    while (K-- && !pq.empty()) {
        auto [sum, i, j] = pq.top(); pq.pop();
        ans += sum;

        if (i-1 >= 0) {
            long long k1 = key(i-1, j);
            if (!seen.count(k1)) {
                seen.insert(k1);
                pq.push({(long long)bandwidth[i-1] + bandwidth[j], i-1, j});
            }
        }
        if (j-1 >= 0) {
            long long k2 = key(i, j-1);
            if (!seen.count(k2)) {
                seen.insert(k2);
                pq.push({(long long)bandwidth[i] + bandwidth[j-1], i, j-1});
            }
        }
    }
    return ans;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n; 
    if (!(cin >> n)) return 0;
    vector<int> a(n);
    for (int i = 0; i < n; ++i) cin >> a[i];
    long long k; 
    cin >> k;

    cout << determineMaxDataFlow(a, k) << "\n";
    return 0;
}




#include <bits/stdc++.h>
using namespace std;

long long determineMaxDataFlow(vector<int> bandwidth, long long streamCount) {
    int n = (int)bandwidth.size();
    sort(bandwidth.begin(), bandwidth.end());
    long long k = streamCount;
    long long totalPairs = 1LL*n*n;
    if (k > totalPairs) k = totalPairs;

    using Node = tuple<long long,int,int>;
    priority_queue<Node> pq;
    unordered_set<long long> vis;
    auto key = [&](int i,int j)->long long { return 1LL*i*n + j; };

    int i = n-1, j = n-1;
    pq.push({(long long)bandwidth[i] + bandwidth[j], i, j});
    vis.insert(key(i,j));

    long long ans = 0;
    while (k-- && !pq.empty()) {
        auto [sum, x, y] = pq.top(); pq.pop();
        ans += sum;

        if (x-1 >= 0) {
            long long k1 = key(x-1, y);
            if (!vis.count(k1)) {
                vis.insert(k1);
                pq.push({(long long)bandwidth[x-1] + bandwidth[y], x-1, y});
            }
        }
        if (y-1 >= 0) {
            long long k2 = key(x, y-1);
            if (!vis.count(k2)) {
                vis.insert(k2);
                pq.push({(long long)bandwidth[x] + bandwidth[y-1], x, y-1});
            }
        }
    }
    return ans;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n; 
    if(!(cin >> n)) return 0;
    vector<int> a(n);
    for (int i = 0; i < n; ++i) cin >> a[i];
    long long k; 
    cin >> k;
    cout << determineMaxDataFlow(a, k) << "\n";
    return 0;
}



#include <bits/stdc++.h>
using namespace std;

long determineMaxDataFlow(vector<int> bandwidth, long streamCount) {
    int n = (int)bandwidth.size();
    sort(bandwidth.begin(), bandwidth.end());
    using T = pair<long long, pair<int,int>>;
    priority_queue<T> pq;
    for (int i = 0; i < n; ++i) pq.push({(long long)bandwidth[i] + bandwidth[n-1], {i, n-1}});
    long long k = streamCount;
    long long totalPairs = 1LL * n * n;
    if (k > totalPairs) k = totalPairs;
    long long ans = 0;
    for (long long t = 0; t < k && !pq.empty(); ++t) {
        auto cur = pq.top(); pq.pop();
        ans += cur.first;
        int i = cur.second.first, j = cur.second.second;
        if (j > 0) pq.push({(long long)bandwidth[i] + bandwidth[j-1], {i, j-1}});
    }
    return (long)ans;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n; 
    if(!(cin >> n)) return 0;
    vector<int> a(n);
    for (int i = 0; i < n; ++i) cin >> a[i];
    long k; 
    cin >> k;
    cout << determineMaxDataFlow(a, k) << "\n";
    return 0;
}


const { concat } = require('rxjs');
const { map, filter, takeWhile, scan } = require('rxjs/operators');

class BasicRXJS {
  function1(inputStream$) {
    return inputStream$.pipe(
      filter(s => typeof s === 'string' && s.length > 3),
      map(s => s.toLowerCase())
    );
  }

  function2(inputStream$) {
    return inputStream$.pipe(
      map(s => {
        if (typeof s !== 'string') return 0;
        const seen = Object.create(null);
        for (let i = 0; i < s.length; i++) seen[s[i]] = 1;
        return Object.keys(seen).length;
      })
    );
  }

  function3(inputStream$) {
    return inputStream$.pipe(takeWhile(s => s !== 'end'));
  }

  function4(inputStream$) {
    const sums$ = inputStream$.pipe(scan((acc, v) => acc + v, 0));
    return concat(sums$, sums$);
  }
}

module.exports = { BasicRXJS };




const { map, filter, takeWhile, scan, repeat } = require('rxjs/operators');

class BasicRXJS {
  function1(inputStream$) {
    return inputStream$.pipe(
      filter(s => typeof s === 'string' && s.length > 3),
      map(s => s.toLowerCase())
    );
  }

  function2(inputStream$) {
    return inputStream$.pipe(
      map(s => (typeof s === 'string' ? new Set(s.split('')).size : 0))
    );
  }

  function3(inputStream$) {
    return inputStream$.pipe(
      takeWhile(s => s !== 'end')
    );
  }

  function4(inputStream$) {
    return inputStream$.pipe(
      scan((acc, cur) => acc + cur, 0),
      repeat(1)
    );
  }
}

module.exports = { BasicRXJS };

